import re
{% if cookiecutter.algorithm_kind == "Detection" %}
from typing import Any, Dict, Iterable, List, Tuple
{% endif %}

import SimpleITK
import numpy as np
{% if cookiecutter.algorithm_kind == "Detection" %}
from pandas import DataFrame
from scipy.ndimage import center_of_mass, label
{% endif %}

from evalutils import BaseAlgorithm
from evalutils.io import SimpleITKLoader
from evalutils.validators import (
    UniquePathIndicesValidator,
    UniqueImagesValidator,
)


class {{ cookiecutter.package_name|capitalize }}(BaseAlgorithm):
    def __init__(self):
        super().__init__(
            index_key="lung",
            file_loaders=dict(lung=SimpleITKLoader()),
            file_filters=dict(lung=re.compile(r"^.*\.mh[ad]$")),
            validators=dict(
                lung=(UniqueImagesValidator(), UniquePathIndicesValidator())
            )
        )

    def process_case(self, *, idx, case):
        lung_path = case["path"]

        # Load the image for this case
        lung = self._file_loaders["lung"].load_image(lung_path)

        # Check that it is the expected image
        if self._file_loaders["lung"].hash_image(lung) != case["hash"]:
            raise RuntimeError("Image hashes do not match")

{% if cookiecutter.algorithm_kind == "Detection" %}
        # Detect and score candidates
        scored_candidates = self.predict(input_image=lung)

        # Write resulting candidates to result.json for this case
        return {
            "outputs": [
                dict(type="candidates", data=scored_candidates.to_dict())
            ],
{% elif cookiecutter.algorithm_kind == "Segmentation" %}
        # Segment nodule candidates
        segmented_nodules = self.predict(input_image=lung)

        # Write resulting segmentation to output location
        segmentation_path = self._output_path / lung_path.name
        if not self._output_path.exists():
            self._output_path.mkdir()
        SimpleITK.WriteImage(segmented_nodules, str(segmentation_path), True)

        # Write resulting file path to result.json for this case
        return {
            "outputs": [
                dict(type="metaio_image", filename=segmentation_path.name)
            ],
{% elif cookiecutter.algorithm_kind == "Classification" %}
        # Classify lung image
        has_nodules = self.predict(input_image=lung)

        # Write resulting classification to result.json for this case
        return {
            "outputs": [
                dict(type="bool", name="has_nodules", value=has_nodules)
            ],
{% endif %}
            "inputs": [dict(type="metaio_image", filename=lung_path.name)],
            "error_messages": [],
        }

{% if cookiecutter.algorithm_kind == "Detection" %}
    def predict(self, *, input_image: SimpleITK.Image) -> DataFrame:
        # Extract a numpy array with image data from the SimpleITK Image
        image_data = SimpleITK.GetArrayFromImage(input_image)

        # Detection: Compute connected components of all values greater than 2
        # in the input image and compute their center of mass
        sample_mask = image_data >= 2
        labels, num_labels = label(sample_mask)
        candidates = center_of_mass(
            input=sample_mask, labels=labels, index=np.arange(num_labels) + 1
        )

        # Scoring: Score each candidate cluster with the value at its center
        candidate_scores = [
            image_data[tuple(coord)]
            for coord in np.array(candidates).astype(np.uint16)
        ]

        # Serialize candidates and scores as a list of dictionary entries
        data = self._serialize_candidates(
            candidates=candidates,
            candidate_scores=candidate_scores,
            ref_image=input_image,
        )

        # Convert serialized candidates to a pandas.DataFrame
        return DataFrame(data)

    def _serialize_candidates(
        self,
        *,
        candidates: Iterable[Tuple[float, ...]],
        candidate_scores: List[Any],
        ref_image: SimpleITK.Image,
    ) -> List[Dict]:
        data = []
        for coord, score in zip(candidates, candidate_scores):
            world_coords = ref_image.TransformContinuousIndexToPhysicalPoint(
                [c for c in reversed(coord)]
            )
            coord_data = {
                f"coord{k}": v for k, v in zip(["X", "Y", "Z"], world_coords)
            }
            coord_data.update({"score": score})
            data.append(coord_data)
        return data
{% elif cookiecutter.algorithm_kind == "Segmentation" %}
    def predict(self, *, input_image: SimpleITK.Image) -> SimpleITK.Image:
        # Segment all values greater than 2 in the input image
        return SimpleITK.BinaryThreshold(
            image1=input_image, lowerThreshold=2, insideValue=1, outsideValue=0
        )
{% elif cookiecutter.algorithm_kind == "Classification" %}
    def predict(self, *, input_image: SimpleITK.Image) -> bool:
        # Checks if there are any nodules voxels (>= 2) in the input image
        return bool(np.any(SimpleITK.GetArrayFromImage(input_image) >= 2))
{% endif %}


if __name__ == "__main__":
    {{ cookiecutter.package_name|capitalize }}().process()
